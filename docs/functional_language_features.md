# <div align = "center">函数式语言特性：迭代器和闭包</div>

## 1. 闭包

### 1.1 使用闭包创建抽象行为

* 闭包：可以**捕获其所在环境的匿名函数**

* 闭包

  * **是匿名函数**
  * 保存为变量、作为参数
  * 可以在某一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算
  * 可以从其定义的作用域内捕获值
* **匿名函数的参数声明在``||``之间，用``,``隔开**

### 1.2 闭包的类型推断

* **闭包不要求标注参数和返回值的类型，但也可以显式标注**
* 闭包通常很短小，只在狭小的上下文工作，编译器通常能推断出类型
* **闭包的定义最终只会为参数/返回值类型推断出唯一具体的值**
  * 第一次使用闭包时就确定了类型，不能当泛型用

### 1.3 使用泛型参数和``Fn Trait``来存储闭包

* 所有的闭包都至少实现了以下``trait``之一
  * ``Fn``
  * ``FnMut``
  * ``FnOnce``
* 例子中使用结构体存储闭包+延迟计算

### 1.4 闭包可以捕获他们所在的环境

* 闭包可以访问定义他的作用域内的变量，而不同函数则不能
* 会产生内存开销
* **闭包从所在环境捕获值的方式**
  * 取得所有权：``FnOnce``
  * 可变借用：``FnMut``
  * 不可变借用：``Fn``
* **创建闭包时，通过闭包对环境值的使用，Rust推断出具体使用哪个trait**
  * 所有的闭包都实现了``FnOnce``
  * 没有移动捕获变量的实现了``FnMut``
  * 无需可变访问捕获变量的闭包实现了``Fn``
* ``move``关键字
  * 在参数列表前使用``move``关键字，可以强制闭包取得他所使用的环境值的所有权
  * **当闭包传递给新线程以移动数据使其归新线程所有时，使用move关键字**
* **当指定``Fn trait bound``之一时，首先用``Fn``，基于闭包体里的情况，如果需要``FnOnce``或``FnMut``，编译器会告诉你**

## 2. 迭代器





