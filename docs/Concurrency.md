# <div align="center">Fearless Concurrency</div>

## 1. 使用线程同时运行代码

> 编程语言实现线程的方式
>
> * 通过调用OS的API来创建线程，``1:1``模型(一个操作系统的线程对应一个语言线程)
>   * 需要较小的运行时
> * 语言自己实现的线程(绿色线程)，``M:N``模型(M个绿色线程对应N个系统线程)
>   * 需要较大的运行时
> * Rust标准库仅提供``1:1``模型的线程

* **通过spawn创建新线程**
  * ``thread::spawn``函数
* ``thread::sleep``导致当前线程暂停执行
* **主线程运行结束会导致其他线程停止**
* **通过join Handle来等待所有线程完成**
  * ``thread::spawn``函数返回值类型是``JoinHandle``
  * ``JoinHandle``持有值的所有权
  * 调用其``join``方法可以等待对应的其他线程的完成
* **join方法通过调用handle的join方法会阻止当前运行线程的执行，直到handle所表示的这些线程终结**

* 使用``move``闭包
  * ``move``闭包通常和``thread::spawn``函数一起使用，**他允许你使用其他线程的数据**

## 2. 使用消息传递来跨线程传递数据

* 消息传递：线程通过彼此发送消息来进行通信
* **Channel(管道)**
  * 包含：发送端/接收端
* **创建channel**
  * 使用``mpsc::channel``函数来创建channel
  * ``mpsc : multiple producer, single consumer``
  * 返回一个元组，里面元素分别为发送端，接收端 
* 发送端的send方法
  * 参数：要发送的数据
  * 返回：``Result<T, E>``
    * 如果有问题，如接收端已经被丢弃，返回一个错误
* 接收端的方法
  * ``recv``方法：阻止当前线程执行，直到channel中有值被送来
    * 一旦有值收到，就会返回Result<T, E>
  * ``try_recv``方法：不会阻塞
    * 立即返回``Result<T, E>``
    * 有数据到达：返回``Ok(data)``
* **channel和所有权转移**
  * 所有权在消息传递中非常重要，保证安全并发
* **通过克隆创建多个发送者**