# <div align = "center">Generic Types, Traits, Lifetimes</div>

## 1. 泛型

* 泛型：提高代码复用能力，解决重复代码问题

* **是具体类型或其他属性的抽象代替**

* 泛型代码不是最终的代码，而是一种模板，里边有一些“占位符”，编译时将“占位符”替换为具体的类型

* 类型参数：惯例为``T``，CamelCase

* **函数定义中的泛型：在函数名后声明泛型**

  * 参数类型

  * 返回类型

    ```rust
    fn largest<T>(list : &[T]) -> T {
    	/*code*/
    }
    ```

* **Struct定义中的泛型：在结构体名后声明泛型**

  * 字段中使用泛型

  ```rust
  struct Point<T, U> {
      x: T,
      y: U,
  }
  ```

  * 可以使用多个泛型

* **Enum定义中的泛型：让枚举的变体持有泛型数据类型**

  * 例如``Option<T>``和``Result<T, E>``

    ```rust
    enum Option<T> {
        Some(T),
        None,
    }
    
    enum Result<T, E> {
        Ok(T),
        Err(E),
    }
    ```

* **方法定义中的泛型**

  * 为``struct``或``enum``实现方法时使用泛型

  * 把T放在``impl``关键字后，表示在类型T上实现方法

    ```rust
    impl<T> Point<T> 
    ```

  * 只针对具体类型实现方法

    ```rust
    impl Point<f32>
    ```

  * **struct里的泛型类型参数可以和方法的泛型类型参数不同**

* **泛型代码的性能：使用泛型代码和使用具体类型的代码运行速度是一样的**

  * 单态化：在编译时将泛型类型替换为具体类型的过程

## 2. Trait

* Trait告诉Rust编译器：某种类型具有哪些可以与其他类型共享的功能

* Trait：抽象的定义共享行为，**类似于Java中的接口**

* ``Trait bounds(约束)``：泛型类型参数指定为实现了特定行为的类型(要求泛型类型参数实现了某些trait)

* **定义一个Trait**

  * Trait的定义：把方法签名放在一起，来定义实现某种目的所必须的一组行为
  * **关键字：trait**
  * 只有方法签名，没有方法具体实现
  * trait可以有多个方法，每个方法签名占一行，以``;``结尾
  * 实现该trait的类型必须提供具体的方法实现

* **在类型上实现trait**

  ```rust
  impl trait_name for type_name { ... }
  ```

* **实现trait的约束**

  * 可以在某个类型上实现某个trait的前提条件是：
    * 这个类型或这个trait是在本地crate里定义的
  * **无法为外部类型来实现外部的trait**

    * 如不能为Vec类型实现Display trait，倘若有多个crate实现了这一点，Rust不知道应该调用哪一个

    * 孤儿原则：父类型不存在，确保其他人写的代码不能破坏您的代码

  * **可以为自定义类型实现外部trait或为外部类型实现自定义trait**

* **默认实现**

  * 可以在trait定义中给出方法的默认实现
  * 如果类型的实现中没有方法实现即采用默认实现
  * 默认实现的方法可以调用trait中的其他方法，即使这些方法没有默认实现
  * **无法从方法的重写实现中调用默认实现**

* **trait作为参数：多态**

  * 参数类型指明为实现接口``item : impl trait_name``：适用于简单情况

  * ``Trait bound``语法，可用于复杂情况

  * **使用+指定多个Trait bound**

    ```rust
    pub fn notify<T: Summary + Display>(item : T) {
        println!("Breaking news! {}", item.summarize());
    }
    ```

  * **在方法签名后使用where子句指定trait bound**

    ```rust
    pub fn notify1<T>(item : T) 
    where T: Summary + Display
    {
        println!("Breaking news! {}", item.summarize());
    }
    ```

* **trait作为返回类型**

  * 返回类型实现接口``impl Trait``
    * 这种方法只能返回确定的同一种类型，返回不同类型的代码会报错
    * 不能实现多态

* **使用trait bound有条件的实现方法**

  * 在使用泛型类型参数的``impl``块上使用``trait bound``，我们可以有条件的为实现了特定``trait``的类型来实现方法

    ```rust
    impl <T: Display + PartialOrd> Pair<T> {...}
    ```

  * 也可以为实现了其他trait的任意类型有条件的实现某个trait

  * 为满足trait bound的所有类型上实现trait叫做覆盖实现(例如满足Display的trait bound的任意类型都实现toString这个trait)

## 3. 生命周期

* Rust的每个引用都有自己的生命周期

* **生命周期：引用保持有效的作用域**

* 大多数情况：生命周期是隐式的，可被推断的

* **当引用的生命周期可能以不同的方式互相关联时，手动标注生命周期**

* **避免悬垂引用：原来指向的内容已经被释放**

* **借用检查器：Rust编译器的借用检查器比较作用域来判断所有的借用是否合法**

* **生命周期标注语法**

  * 生命周期的标注不会改变引用的生命周期长度

  * 当指定了**泛型生命周期参数**，函数可以接收带有任何生命周期的引用

  * **生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期**

  * **生命周期参数名：**

    * 以``'``开头
    * 通常全小写且非常短
    * 很多人使用``'a``

  * 生命周期标注位置：引用``&``符号之后

    ```rust
    &'a i32
    &'a mut i32
    ```

* **单个生命周期的标注本身没有意义，是为了表述多个引用间的生命周期关系(简单来说就是对需要的生命周期分组命名)**

* 一个例子

  ```rust
  fn longest<'a> (x: &'a str, y: &'a str) -> &'a str {
      if x.len() > y.len() {
          x
      } else {
          y
      }
  }
  ```

  * 泛型中只声明了一种生命周期长度，返回值与两个参数具有相同的生命周期
  * 在参数传入时，``'a``被确定为参数x和y中**比较短**的那个生命周期

* **函数签名中的生命周期标注**

  * 泛型生命周期参数声明在：函数名和参数列表之间的``<>``中

* **深入理解生命周期**

  * 指定生命周期的方式取决于函数所做的事情
  * 当函数返回引用时，**返回类型的生命周期需要与其中一个参数的生命周期匹配**
  * 如果返回的引用没有指向任何参数，那么它只能指向函数内创建的值
    * 这就是悬垂引用，该值在函数结束后就走出了作用域

* **struct定义中的生命周期标注**

  * ``struct``中可包括
    * 自持有类型
    * 引用类型：每个引用上添加生命周期标注

* 生命周期的省略

  * 每个引用都有生命周期
  * 需要为使用生命周期的函数或``struct``指定生命周期参数
  * 在Rust引用分析中所编入的模式称为生命周期省略规则
    * 这些规则无需开发者遵守
    * 他们是一些特殊情况，由编译器来考虑
    * 如果你的代码符合这些情况，就无需显式标注生命周期
  * 生命周期省略规则不会提供完整的推断
    * 如果应用规则后，引用的生命周期仍然模糊不清``->``编译错误

* **输入/输出生命周期**

  * 函数/方法的参数：输入生命周期
  * 函数/方法的返回值：输出生命周期

* **生命周期省略的三个规则**

  > 编译器使用3个规则在没有显式标注生命周期的情况下来确定引用的生命周期
  >
  > * 规则一：输入生命周期
  > * 规则二/三：输出生命周期
  >
  > 编译器引用过三个规则之后仍然无法确定生命周期的引用：报错
  >
  > 这些规则适用于``fn``定义和``impl``块

  * 规则一：每个引用类型的参数都有自己的生命周期
  * 规则二：如果只有一个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数
  * 规则三：如果有多个输入生命周期参数，但其中一个是``&self``或``&mut self``(是方法)，那么self的生命周期会被赋给所有的输出生命周期参数

* **方法定义中的生命周期标注**

  * 在``struct``上使用生命周期实现方法，语法和泛型参数的语法一样
  * 在哪声明和使用生命周期参数，依赖于
    * 生命周期参数是否和字段、方法的参数或返回值有关
  * ``struct``字段的生命周期名：
    * 在``impl``后声明
    * 在``struct``名后使用
  * ``impl``块内的方法签名中
    * 引用必须绑定于``struct``字段引用的生命周期，或者引用是独立的也可以
    * 生命周期省略规则经常使得方法中的生命周期标注不是必需的

* **静态生命周期**

  * 静态生命周期：``'static``是一个特殊的生命周期，整个程序的持续时间

    * 所有的字符串字面值都有``'static``生命周期

      ```rust
      let s: &'static str = "hello";
      ```

* 生命周期的声明和泛型的声明在一个``<>``中，用``,``隔开





