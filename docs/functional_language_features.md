# <div align = "center">函数式语言特性：迭代器和闭包</div>

## 1. 闭包

### 1.1 使用闭包创建抽象行为

* 闭包：可以**捕获其所在环境的匿名函数**

* 闭包

  * **是匿名函数**
  * 保存为变量、作为参数
  * 可以在某一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算
  * 可以从其定义的作用域内捕获值
* **匿名函数的参数声明在``||``之间，用``,``隔开**

### 1.2 闭包的类型推断

* **闭包不要求标注参数和返回值的类型，但也可以显式标注**
* 闭包通常很短小，只在狭小的上下文工作，编译器通常能推断出类型
* **闭包的定义最终只会为参数/返回值类型推断出唯一具体的值**
  * 第一次使用闭包时就确定了类型，不能当泛型用

### 1.3 使用泛型参数和``Fn Trait``来存储闭包

* 所有的闭包都至少实现了以下``trait``之一
  * ``Fn``
  * ``FnMut``
  * ``FnOnce``
* 例子中使用结构体存储闭包+延迟计算

### 1.4 闭包可以捕获他们所在的环境

* 闭包可以访问定义他的作用域内的变量，而不同函数则不能
* 会产生内存开销
* **闭包从所在环境捕获值的方式**
  * 取得所有权：``FnOnce``
  * 可变借用：``FnMut``
  * 不可变借用：``Fn``
* **创建闭包时，通过闭包对环境值的使用，Rust推断出具体使用哪个trait**
  * 所有的闭包都实现了``FnOnce``
  * 没有移动捕获变量的实现了``FnMut``
  * 无需可变访问捕获变量的闭包实现了``Fn``
* ``move``关键字
  * 在参数列表前使用``move``关键字，可以强制闭包取得他所使用的环境值的所有权
  * **当闭包传递给新线程以移动数据使其归新线程所有时，使用move关键字**
* **当指定``Fn trait bound``之一时，首先用``Fn``，基于闭包体里的情况，如果需要``FnOnce``或``FnMut``，编译器会告诉你**

## 2. 迭代器

* 迭代器模式：对一系列项执行某些任务
* 迭代器负责
  * 遍历每个项
  * 确定序列遍历何时完成
* **Rust中的迭代器**
  * 惰性的：除非调用消耗迭代器的方法，否则迭代器本身没有任何效果

### 2.1 ``Iterrator trait``和``next``方法

* 所有的迭代器都实现了``iterator trait``
* ``iterator trait``仅要求实现一个方法：``next``
* ``next``方法：
  * 每次返回迭代器中的一项
  * **返回结果包裹在``Some``中**
  * **迭代结束，返回``None``**
* 可以直接在迭代器上调用``iter``方法
* **几个迭代方法**
  * ``iter()``方法：在不可变引用上创建迭代器
  * ``into_iter()``方法：创建的迭代器会获取所有权

### 2.2 消耗/产生迭代器

* **消耗迭代器的方法**
  * 在标准库中，``Iterator trait``有一些带默认实现的方法
  * 其中有一些方法会调用``next``方法
    * **实现iterator trait时必须实现next方法**
  * **调用next的方法叫做消耗型适配器：会把迭代器耗尽，例如sum方法**
* **产生其他迭代器的方法**
  * 定义在``iterator trait``上的另外一些方法叫做“迭代器适配器”
    * 把迭代器转换为不同种类的迭代器
  * 链式调用迭代器
  * ``colloct``方法：消耗型适配器，把结果收集到一个集合类型中

### 2.3 使用闭包捕获环境

* ``filter()``方法

  * 接受一个闭包，作为判断条件

    ```rust
    contents.lines().filter(|line| line.contains(query));
    ```

  * 遍历每个元素时，返回``bool``类型

    * 如果返回``true``，当前元素将会包含在``filter``产生的迭代器中
    * 如果返回``false``，则不会被包含

### 2.4 使用iterator trait创建自定义迭代器

* **实现next方法**
* ```impl Iterator for XXX```
* ``skip(index)``跳过元素

### 2.5 循环和迭代器性能比较

* **Rust零开销抽象**：使用抽象时，不会引入额外的运行时开销，但会增加编译成本
* 迭代器是循环的高层次抽象，在编译时产物为低层次的代码，例如手写循环等
  * 编译为低层次的代码可能会优于手写，最差等同手写
* **使用Rust提供的迭代器性能会比手写循环优/相同**







